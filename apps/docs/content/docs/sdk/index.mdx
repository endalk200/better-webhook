---
title: SDK Getting Started
description: Build type-safe webhook handlers with automatic signature verification using Better Webhook SDK packages.
---

import { Steps, Step } from "fumadocs-ui/components/steps";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Callout } from "fumadocs-ui/components/callout";

# SDK Getting Started

The Better Webhook SDK provides type-safe webhook handlers with automatic signature verification. It consists of:

- **Provider packages** — Type definitions and schemas for webhook sources (GitHub, Ragie, Recall.ai)
- **Adapter packages** — Framework integrations (Next.js, Hono, Express, NestJS, GCP Cloud Functions)
- **Core package** — Base functionality for custom providers

## Installation

Install a provider and an adapter for your framework:

<Tabs items={["Next.js", "Express", "NestJS", "GCP Cloud Functions", "Hono"]}>
  <Tab value="Next.js">
    <Tabs groupId="package-manager" items={["npm", "pnpm", "yarn"]}>
      <Tab value="npm">
        ```bash
        npm install @better-webhook/github @better-webhook/nextjs
        ```
      </Tab>
      <Tab value="pnpm">
        ```bash
        pnpm add @better-webhook/github @better-webhook/nextjs
        ```
      </Tab>
      <Tab value="yarn">
        ```bash
        yarn add @better-webhook/github @better-webhook/nextjs
        ```
      </Tab>
    </Tabs>
  </Tab>
  <Tab value="Express">
    <Tabs groupId="package-manager" items={["npm", "pnpm", "yarn"]}>
      <Tab value="npm">
        ```bash
        npm install @better-webhook/github @better-webhook/express
        ```
      </Tab>
      <Tab value="pnpm">
        ```bash
        pnpm add @better-webhook/github @better-webhook/express
        ```
      </Tab>
      <Tab value="yarn">
        ```bash
        yarn add @better-webhook/github @better-webhook/express 
        ```
      </Tab>
    </Tabs>
  </Tab>
  <Tab value="NestJS">
    <Tabs groupId="package-manager" items={["npm", "pnpm", "yarn"]}>
      <Tab value="npm">
        ```bash
        npm install @better-webhook/github @better-webhook/nestjs 
        ```
      </Tab>
      <Tab value="pnpm">
        ```bash
        pnpm add @better-webhook/github @better-webhook/nestjs
        ```
      </Tab>
      <Tab value="yarn">
        ```bash
        yarn add @better-webhook/github @better-webhook/nestjs
        ```
      </Tab>
    </Tabs>
  </Tab>
  <Tab value="GCP Cloud Functions">
    <Tabs groupId="package-manager" items={["npm", "pnpm", "yarn"]}>
      <Tab value="npm">
        ```bash
        npm install @better-webhook/ragie @better-webhook/gcp-functions
        ```
      </Tab>
      <Tab value="pnpm">
        ```bash
        pnpm add @better-webhook/ragie @better-webhook/gcp-functions
        ```
      </Tab>
      <Tab value="yarn">
        ```bash
        yarn add @better-webhook/ragie @better-webhook/gcp-functions
        ```
      </Tab>
    </Tabs>
  </Tab>
  <Tab value="Hono">
    <Tabs groupId="package-manager" items={["npm", "pnpm", "yarn"]}>
      <Tab value="npm">
        ```bash
        npm install @better-webhook/github @better-webhook/hono
        ```
      </Tab>
      <Tab value="pnpm">
        ```bash
        pnpm add @better-webhook/github @better-webhook/hono
        ```
      </Tab>
      <Tab value="yarn">
        ```bash
        yarn add @better-webhook/github @better-webhook/hono
        ```
      </Tab>
    </Tabs>
  </Tab>
</Tabs>

## Quick Example

<Tabs items={['Next.js', 'Express', 'NestJS', 'GCP Cloud Functions', 'Hono']}>
  <Tab value="Next.js">
    ```ts title="app/api/webhooks/github/route.ts"
    import { github } from "@better-webhook/github";
    import { push, pull_request } from "@better-webhook/github/events";
    import { toNextJS } from "@better-webhook/nextjs";

    const webhook = github()
      .event(push, async (payload) => {
        // payload is fully typed!
        console.log(`Push to ${payload.repository.name}`);
        console.log(`${payload.commits.length} commits`);
      })
      .event(pull_request, async (payload) => {
        if (payload.action === "opened") {
          console.log(`New PR: ${payload.pull_request.title}`);
        }
      });

    export const POST = toNextJS(webhook);
    ```

  </Tab>
  <Tab value="Express">
    ```ts title="src/webhooks.ts"
    import express from "express";
    import { github } from "@better-webhook/github";
    import { push } from "@better-webhook/github/events";
    import { toExpress } from "@better-webhook/express";

    const app = express();

    const webhook = github()
      .event(push, async (payload) => {
        console.log(`Push to ${payload.repository.name}`);
      });

    // Important: use express.raw() for signature verification
    app.post(
      "/webhooks/github",
      express.raw({ type: "application/json" }),
      toExpress(webhook)
    );

    app.listen(3000);
    ```

  </Tab>
  <Tab value="NestJS">
    ```ts title="src/webhooks.controller.ts"
    import { Controller, Post, Req, Res } from "@nestjs/common";
    import { Request, Response } from "express";
    import { github } from "@better-webhook/github";
    import { push } from "@better-webhook/github/events";
    import { toNestJS } from "@better-webhook/nestjs";

    @Controller("webhooks")
    export class WebhooksController {
      private webhook = github()
        .event(push, async (payload) => {
          console.log(`Push to ${payload.repository.name}`);
        });

      @Post("github")
      async handleGitHub(@Req() req: Request, @Res() res: Response) {
        const result = await toNestJS(this.webhook)(req);
        return res.status(result.statusCode).json(result.body);
      }
    }
    ```

  </Tab>
  <Tab value="GCP Cloud Functions">
    ```ts title="index.ts"
    import { http } from "@google-cloud/functions-framework";
    import { ragie } from "@better-webhook/ragie";
    import { document_status_updated, connection_sync_finished } from "@better-webhook/ragie/events";
    import { toGCPFunction } from "@better-webhook/gcp-functions";

    const webhook = ragie()
      .event(document_status_updated, async (payload) => {
        // payload is fully typed!
        console.log(`Document ${payload.document_id} is now ${payload.status}`);
      })
      .event(connection_sync_finished, async (payload) => {
        console.log(`Sync ${payload.sync_id} completed`);
      });

    http("webhookHandler", toGCPFunction(webhook));
    ```

  </Tab>
  <Tab value="Hono">
    ```ts title="src/webhooks.ts"
    import { Hono } from "hono";
    import { github } from "@better-webhook/github";
    import { push } from "@better-webhook/github/events";
    import { toHono } from "@better-webhook/hono";

    const app = new Hono();

    const webhook = github()
      .event(push, async (payload) => {
        console.log(`Push to ${payload.repository.name}`);
      });

    app.post("/webhooks/github", toHono(webhook));

    export default app;
    ```

  </Tab>
</Tabs>

## Tree-Shaking

Events are exported separately from each provider's `/events` subpath, enabling bundlers to tree-shake unused events:

```ts
// Only the push schema is included in your bundle
import { push } from "@better-webhook/github/events";

// Multiple events - only these schemas are included
import { push, pull_request } from "@better-webhook/github/events";
```

This is especially beneficial for serverless deployments where bundle size matters.

## How It Works

<Steps>
  <Step>
    ### Create a Webhook Builder

    Use a provider function (like `github()`) to create a webhook builder:

    ```ts
    import { github } from "@better-webhook/github";

    const webhook = github();
    ```

  </Step>

  <Step>
    ### Import Events

    Import the specific events you want to handle from the `/events` subpath:

    ```ts
    import { push, issues } from "@better-webhook/github/events";
    ```

  </Step>

  <Step>
    ### Register Event Handlers

    Chain `.event()` calls to register handlers for specific event types:

    ```ts
    const webhook = github()
      .event(push, async (payload) => {
        // Handle push events
      })
      .event(issues, async (payload) => {
        // Handle issues events
      });
    ```

    Each handler receives a fully typed payload with autocomplete support.

  </Step>

  <Step>
    ### Convert to Framework Handler

    Use an adapter to convert the webhook builder to your framework's handler format:

    ```ts
    // Next.js
    export const POST = toNextJS(webhook);

    // Express
    app.post("/webhooks/github", express.raw({ type: "application/json" }), toExpress(webhook));

    // NestJS
    const result = await toNestJS(this.webhook)(req);

    // GCP Cloud Functions
    http("webhookHandler", toGCPFunction(webhook));

    // Hono
    app.post("/webhooks/github", toHono(webhook));
    ```

  </Step>
</Steps>

## Signature Verification

Signature verification happens automatically when you provide a secret. The SDK looks for secrets in this order:

1. **Adapter options** — Pass `secret` to the adapter function
2. **Provider options** — Pass `secret` when creating the provider
3. **Environment variables** — Automatically checks `GITHUB_WEBHOOK_SECRET`, `RAGIE_WEBHOOK_SECRET`, `RECALL_WEBHOOK_SECRET`, etc.

```ts
// Option 1: Adapter options
export const POST = toNextJS(webhook, {
  secret: process.env.GITHUB_WEBHOOK_SECRET,
});

// Option 2: Provider options
const webhook = github({
  secret: process.env.GITHUB_WEBHOOK_SECRET,
});

// Option 3: Environment variable (automatic)
// Just set GITHUB_WEBHOOK_SECRET in your environment
```

Verification is evaluated before unhandled-event routing. Requests for unknown
event types still need to pass signature verification before receiving `204`.

<Callout type="warn">
  Always configure signature verification in production. Without it, anyone can
  send fake webhooks to your endpoint.
</Callout>

## Replay Protection

Use core replay protection to enforce deduplication with a pluggable store:

```ts
import { createInMemoryReplayStore } from "@better-webhook/core";
import { github } from "@better-webhook/github";
import { push } from "@better-webhook/github/events";

const replayStore = createInMemoryReplayStore();

const webhook = github()
  .withReplayProtection({ store: replayStore })
  .event(push, async (payload) => {
    console.log(`Push to ${payload.repository.full_name}`);
  });
```

Default duplicate behavior is `409`.

## Error Handling

Register error handlers to catch validation and handler errors:

```ts
import { push } from "@better-webhook/github/events";

const webhook = github()
  .event(push, async (payload) => {
    // Your handler
  })
  .onError((error, context) => {
    console.error(`Error in ${context.eventType}:`, error);
    // Log to monitoring service, etc.
  })
  .onVerificationFailed((reason, headers) => {
    console.warn("Signature verification failed:", reason);
    // Alert on potential attacks
  });
```

## Observability

Add metrics, logging, and tracing to your webhook handlers with the built-in observer API:

```ts
import { github } from "@better-webhook/github";
import { push } from "@better-webhook/github/events";
import { createWebhookStats } from "@better-webhook/core";
import { toNextJS } from "@better-webhook/nextjs";

// Built-in stats collector
const stats = createWebhookStats();

const webhook = github()
  .observe(stats.observer)
  .event(push, async (payload) => {
    console.log(`Push to ${payload.repository.name}`);
  });

export const POST = toNextJS(webhook);

// Access stats anytime
console.log(stats.snapshot());
// { totalRequests: 150, successCount: 145, errorCount: 5, ... }
```

### Custom Observers

Create custom observers to integrate with your metrics infrastructure:

```ts
import { type WebhookObserver } from "@better-webhook/core";

const metricsObserver: WebhookObserver = {
  onCompleted: (event) => {
    metrics.histogram("webhook_duration_ms", event.durationMs, {
      provider: event.provider,
      eventType: event.eventType,
      status: String(event.status),
    });
  },
  onHandlerFailed: (event) => {
    logger.error("Webhook handler failed", {
      error: event.error.message,
      provider: event.provider,
      eventType: event.eventType,
    });
  },
};

const webhook = github().observe(metricsObserver).event(push, handler);
```

You can also add observers at the adapter level:

```ts
export const POST = toNextJS(webhook, {
  observer: metricsObserver,
});
```

## Next Steps

- [Providers](/docs/sdk/providers) — GitHub, Ragie, and Recall.ai provider documentation with all supported events
- [Adapters](/docs/sdk/adapters) — Framework-specific setup and configuration
